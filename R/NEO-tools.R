#' Converts the output of \code{NEO} into something sane.
#' 
#' \code{NEO} outputs a massive CSV file that is not easily parseable, nor
#' loadable into cytoscape. This function will parse this CSV file and write
#' two tables to file in tab separatted format: 
#' An edge table, filled with relevant columns, notably
#' splitting out the \code{edge} column into Source and Target nodes, and 
#' splitting the \code{Final.SNPs.LEO.NB.OCA} column into a vector of SNPs for 
#' the target and source nodes respectively, and a second table with SNP to Node 
#' relationships.
#' 
#' @param neofilename path to the neo csv file.
#' @param outfile file prefix to output the .edge.table.tsv and .snp.table.tsv
#'        files
#' @param datC data matrix given to NEO as its \code{datC} argument
#' @export
parseNEOcsv <- function(neofilename, outfile, datC) {
  require(data.table)
  neo.csv <- read.csv(neofilename, stringsAsFactors=FALSE)
  snps <- strsplit(gsub('"', '', neo.csv$Final.SNPs.LEO.NB.OCA), ";")
  if (!("edge" %in% neo.csv)) {
    warning("parsing incomplete neo log file. Your run may have failed, or is",
            " still in progress.")
    colnames(neo.csv)[1] <- "edge"
  }
  dt <- data.table(
    Source = sapply(strsplit(neo.csv$edge, " -> "), `[`, 1),
    Target = sapply(strsplit(neo.csv$edge, " -> "), `[`, 2),
    CPA.Anchors = sapply(snps, function(x) gsub("fsnp.cpa=", "", x[1])),
    OCA.Anchors = sapply(snps, function(x) gsub("fsnp.oca=", "", x[2])),
    LEO.NB.OCA = neo.csv$LEO.NB.OCA,
    LEO.NB.CPA = neo.csv$LEO.NB.CPA,
    P.Model.AB = neo.csv$Model.P.value.AtoB,
    P.weighted.LEO.NB.OCA = neo.csv$P.weighted.LEO.NB.OCA,
    Z.WaldPath.AB = neo.csv$ZtestPathCoefficientAB,
    P.WaldPath.AB = 2*pnorm(abs(neo.csv$ZtestPathCoefficientAB), lower.tail=FALSE),
    BLV = neo.csv$BLV.or.BilayerZscore,
    PearsonCor = neo.csv$PearsonCor
  )
  
  edge.table <- evaluateAnchors(dt[!is.na(CPA.Anchors) | !is.na(OCA.Anchors)], 
                                datC)
  snp.table <- dt[is.na(CPA.Anchors) & is.na(OCA.Anchors), 
                  c("Source", "Target", "PearsonCor")]
  
  write.table(edge.table, 
              file=paste0(outfile, ".edge.table.tsv"), 
              quote=FALSE, sep="\t")
  write.table(snp.table,
              file=paste0(outfile, ".snp.table.tsv"),
              quote=FALSE, sep="\t")
}

#' Filter a NEO edge table by the recommended thresholds
#' 
#' @param edgeTable edge.table generated by \code{\link{parseNEOcsv}}.
#' 
#' @return a subset of the edge table containing only significant edges.
#' @export
filterNEO <- function(dt) {
  require(data.table)
  dt[LEO.NB.OCA > 0.3 & 
     LEO.NB.CPA > 0 & 
     P.Model.AB > 0.05 & 
     P.weighted.LEO.NB.OCA > 0.05 & 
     P.WaldPath.AB < 0.05 & 
     BLV > 0]
}

#' Parse an anchor column to obtain all unique SNPs
#' 
#' @param anchors the CPA.Anchors or OCA.Anchors column to parse
#' @return a list of all SNPs that appear in the column
#' @export
parseAnchors <- function(anchors) {
  unique(unlist(lapply(anchors, parseAnchor)))
}

#' Parse the entry of an anchor column
parseAnchor <- function(anchor) {
  x <- gsub("c\\(", "", anchor)
  x <- gsub("\\)", "", x)
  strsplit(x, ",")[[1]]
}

#' Evalute the Quality of the Causal and Orthoganl Anchors chosen by NEO.
#' 
#' @param dt edge table to be written out by \code{\link{parseNEOcsv}}.
#' @param datC matrix given to NEO
#' @param qtls a combined table of QTL associations generated by \code{plink} 
#'             for each trait. Table should have a column named \code{PHEN}
#' @return 
#'   \code{edge.table} with the following columns added:
#'   \itemize{
#'     \item{CPA.P}{
#'      Model p-value for a linear model of the CPA anchors on the Source node,
#'      in the subset of individuals in \code{datC}.
#'     }
#'     \item{CPA.R2}{
#'      Adjusted R-squared for a linear model of the CPA anchors on the Source
#'      node, in the subset of individuals in \code{datC}.
#'     }
#'     \item{OCA.P}{
#'      Model p-value for a linear model of the OCA anchors on the Target node,
#'      in the subset of individuals in \code{datC}.
#'     }
#'     \item{OCA.R2}{
#'      Adjusted R-squared for a linear model of the OCA anchors on the Target
#'      node, in the subset of individuals in \code{datC}.
#'     }
#'   }
#' 
evaluateAnchors <- function(dt, datC) {
  CPA.Source.P  <- rep(NA, dt[,.N])
  CPA.Source.R2 <- rep(NA, dt[,.N])
  CPA.Target.P  <- rep(NA, dt[,.N])
  CPA.Target.R2 <- rep(NA, dt[,.N])
  OCA.Source.P  <- rep(NA, dt[,.N])
  OCA.Source.R2 <- rep(NA, dt[,.N])
  OCA.Target.P  <- rep(NA, dt[,.N])
  OCA.Target.R2 <- rep(NA, dt[,.N])
  for (i in dt[,.I]) {
    cpa.to.source = anchor.lm(datC, dt[i, Source], dt[i,CPA.Anchors])
    cpa.to.target = anchor.lm(datC, dt[i, Target], dt[i,CPA.Anchors])
    oca.to.source = anchor.lm(datC, dt[i, Source], dt[i,OCA.Anchors])
    oca.to.target = anchor.lm(datC, dt[i, Target], dt[i,OCA.Anchors])
    f <- summary(cpa.to.source)$fstat
    CPA.Source.P[i]  = pf(f[1], f[2], f[3], lower.tail=F)
    CPA.Source.R2[i] = summary(cpa.to.source)$adj.r.squared
    f <- summary(cpa.to.target)$fstat
    CPA.Target.P[i]  = pf(f[1], f[2], f[3], lower.tail=F)
    CPA.Target.R2[i] = summary(cpa.to.target)$adj.r.squared
    f <- summary(oca.to.source)$fstat
    OCA.Source.P[i]  = pf(f[1], f[2], f[3], lower.tail=F)
    OCA.Source.R2[i] = summary(oca.to.source)$adj.r.squared
    f <- summary(oca.to.target)$fstat
    OCA.Target.P[i]  = pf(f[1], f[2], f[3], lower.tail=F)
    OCA.Target.R2[i] = summary(oca.to.target)$adj.r.squared
  }
  dt[, CPA.Source.P  := CPA.Source.P]
  dt[, CPA.Source.R2 := CPA.Source.R2]
  dt[, OCA.Target.P  := OCA.Target.P]
  dt[, OCA.Target.R2 := OCA.Target.R2]
  dt[, CPA.Target.P  := CPA.Target.P]
  dt[, CPA.Target.R2 := CPA.Target.R2]
  dt[, OCA.Source.P  := OCA.Source.P]
  dt[, OCA.Source.R2 :- OCA.Source.R2]
  dt
}

# Run a linear model between a trait and its causal anchors.
anchor.lm <- function(datC, trait, anchor) {
  anchors <- parseAnchor(anchor)
  call <- paste0("lm(", trait, " ~ ", paste(anchors, collapse=" + "), 
                 ", dat=as.data.frame(datC))")
  eval(parse(text=call))
}
